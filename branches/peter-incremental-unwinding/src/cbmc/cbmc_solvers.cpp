/*******************************************************************\

Module: Solvers for VCs Generated by Symbolic Execution of ANSI-C

Author: Daniel Kroening, kroening@kroening.com

\*******************************************************************/

#include <memory>
#include <iostream>

#include <solvers/sat/satcheck.h>
#include <solvers/sat/satcheck_minisat2.h>

#include <solvers/refinement/bv_refinement.h>
#include <solvers/smt1/smt1_dec.h>
#include <solvers/smt2/smt2_dec.h>
#include <solvers/cvc/cvc_dec.h>

#include <solvers/prop/aig_prop.h>

#include "bmc.h"
#include "bv_cbmc.h"
#include "counterexample_beautification.h"
#include "version.h"

/*******************************************************************\

Function: bmct::decide_default

  Inputs:

 Outputs:

 Purpose: Decide using "default" decision procedure

\*******************************************************************/

bool bmct::decide_default()
{
  bool result=true;
  
  std::auto_ptr<propt> solver;

  // SAT preprocessor won't work with beautification.
  if(options.get_bool_option("sat-preprocessor") &&
     !options.get_bool_option("beautify"))
  {
    solver=std::auto_ptr<propt>(new satcheckt);
  }
  else
    solver=std::auto_ptr<propt>(new satcheck_minisat_no_simplifiert);

  solver->set_message_handler(get_message_handler());
  solver->set_verbosity(get_verbosity());
    
  bv_cbmct bv_cbmc(ns, *solver);
    
  if(options.get_option("arrays-uf")=="never")
    bv_cbmc.unbounded_array=bv_cbmct::U_NONE;
  else if(options.get_option("arrays-uf")=="always")
    bv_cbmc.unbounded_array=bv_cbmct::U_ALL;
    
  switch(run_decision_procedure(bv_cbmc))
  {
  case decision_proceduret::D_UNSATISFIABLE:
    result=false;
    report_success();
    break;

  case decision_proceduret::D_SATISFIABLE:
    if(options.get_bool_option("beautify"))
      counterexample_beautificationt()(
        bv_cbmc, equation, ns);

    error_trace(bv_cbmc);
    report_failure();
    break;

  default:
    error() << "decision procedure failed" << eom;
  }

  return result;
}

/*******************************************************************\

Function: bmct::decide_aig

  Inputs:

 Outputs:

 Purpose: Decide using AIG followed by SAT

\*******************************************************************/

bool bmct::decide_aig()
{
  bool result=true;

  std::auto_ptr<propt> sub_solver;

  if(options.get_bool_option("sat-preprocessor"))
    sub_solver=std::auto_ptr<propt>(new satcheckt);
  else
    sub_solver=std::auto_ptr<propt>(new satcheck_minisat_no_simplifiert);

  aig_prop_solvert solver(*sub_solver);

  solver.set_message_handler(get_message_handler());
  solver.set_verbosity(get_verbosity());
    
  bv_cbmct bv_cbmc(ns, solver);
    
  if(options.get_option("arrays-uf")=="never")
    bv_cbmc.unbounded_array=bv_cbmct::U_NONE;
  else if(options.get_option("arrays-uf")=="always")
    bv_cbmc.unbounded_array=bv_cbmct::U_ALL;
    
  switch(run_decision_procedure(bv_cbmc))
  {
  case decision_proceduret::D_UNSATISFIABLE:
    result=false;
    report_success();
    break;

  case decision_proceduret::D_SATISFIABLE:
    error_trace(bv_cbmc);
    report_failure();
    break;

  default:
    error() << "decision procedure failed" << eom;
  }

  return result;
}

/*******************************************************************\

Function: bmct::bv_refinement

  Inputs:

 Outputs:

 Purpose: Decide using refinement decision procedure

\*******************************************************************/

bool bmct::decide_bv_refinement()
{
  std::auto_ptr<propt> solver;

  // We offer the option to disable the SAT preprocessor
  if(options.get_bool_option("sat-preprocessor"))
    solver=std::auto_ptr<propt>(new satcheckt);
  else
    solver=std::auto_ptr<propt>(new satcheck_minisat_no_simplifiert);
  
  solver->set_message_handler(get_message_handler());
  solver->set_verbosity(get_verbosity());

  bv_refinementt bv_refinement(ns, *solver);

  // we allow setting some parameters  
  if(options.get_option("max-node-refinement")!="")
    bv_refinement.max_node_refinement=options.get_int_option("max-node-refinement");
  
  return decide(bv_refinement);
}

/*******************************************************************\

Function: cbmc_solverst::get_smt1

  Inputs:

 Outputs:

 Purpose:

\*******************************************************************/
 
prop_convt* cbmc_solverst::get_smt1(smt1_dect::solvert solver)
{
  no_beautification();
  no_incremental_check();

  const std::string &filename=options.get_option("outfile");
  
  if(filename=="")
  {
    smt1_dect* smt1_dec = new smt1_dect(
      ns,
      "cbmc",
      "Generated by CBMC " CBMC_VERSION,
      "QF_AUFBV",
      solver);
    return smt1_dec;
  }
  else if(filename=="-") {
    smt1_convt* smt1_conv = new smt1_convt(
      ns,
      "cbmc",
      "Generated by CBMC " CBMC_VERSION,
      "QF_AUFBV",
      std::cout);
    smt1_conv->set_message_handler(get_message_handler());
    return smt1_conv;
  }
  else
  {
    std::ofstream out(filename.c_str());
    if(!out)
    {
      std::cerr << "failed to open " << filename << std::endl;
      return false;
    }
    smt1_convt* smt1_conv = new smt1_convt(
      ns,
      "cbmc",
      "Generated by CBMC " CBMC_VERSION,
      "QF_AUFBV",
      std::cout);
    smt1_conv->set_message_handler(get_message_handler());
    return smt1_conv;
  }
}
  
/*******************************************************************\

Function: cbmc_solverst::get_smt2

  Inputs:

 Outputs:

 Purpose:

\*******************************************************************/
   
prop_convt* cbmc_solverst::get_smt2(smt2_dect::solvert solver)
{
  no_beautification();
  no_incremental_check();

  const std::string &filename=options.get_option("outfile");
  
  if(filename=="")
  {
    smt2_dect* smt2_dec = new smt2_dect(
      ns,
      "cbmc",
      "Generated by CBMC " CBMC_VERSION,
      "QF_AUFBV",
      solver);

    if(options.get_bool_option("fpa"))
      smt2_dec->use_FPA_theory=true;

    return smt2_dec;
  }
  else if(filename=="-") {
    smt2_convt* smt2_conv = new smt2_convt(
      ns,
      "cbmc",
      "Generated by CBMC " CBMC_VERSION,
      "QF_AUFBV",
      std::cout);

    if(options.get_bool_option("fpa"))
      smt2_conv->use_FPA_theory=true;

    smt2_conv->set_message_handler(get_message_handler());
    return smt2_conv;
  }
  else
  {
    std::ofstream out(filename.c_str());
    if(!out)
    {
      std::cerr << "failed to open " << filename << std::endl;
      return false;
    }
    smt2_convt* smt2_conv = new smt2_convt(
      ns,
      "cbmc",
      "Generated by CBMC " CBMC_VERSION,
      "QF_AUFBV",
      out);

    if(options.get_bool_option("fpa"))
      smt2_conv->use_FPA_theory=true;

    smt2_conv->set_message_handler(get_message_handler());
    return smt2_conv;
  }
}

/*******************************************************************\

Function: cbmc_solverst::get_cvc

  Inputs:

 Outputs:

 Purpose:

\*******************************************************************/
     
prop_convt* cbmc_solverst::get_cvc()
{
  return get_smt1(smt1_dect::CVC3);
}
    
/*******************************************************************\

Function: cbmc_solverst::get_boolector

  Inputs:

 Outputs:

 Purpose:

\*******************************************************************/
      
prop_convt* cbmc_solverst::get_boolector()
{
  return get_smt1(smt1_dect::BOOLECTOR);
}

/*******************************************************************\

Function: cbmc_solverst::get_mathsat

  Inputs:

 Outputs:

 Purpose:

\*******************************************************************/
       
prop_convt* cbmc_solverst::get_mathsat()
{
  if(options.get_bool_option("smt2"))
    return get_smt2(smt2_dect::MATHSAT);
  else
    return get_smt1(smt1_dect::MATHSAT);
}
      
/*******************************************************************\

Function: cbmc_solverst::get_opensmt

  Inputs:

 Outputs:

 Purpose:

\*******************************************************************/
	
prop_convt* cbmc_solverst::get_opensmt()
{
  return get_smt1(smt1_dect::OPENSMT);
}

/*******************************************************************\

Function: cbmc_solverst::get_z3

  Inputs:

 Outputs:

 Purpose:

\*******************************************************************/
	 
prop_convt* cbmc_solverst::get_z3()
{
  return get_smt2(smt2_dect::Z3);
}
	 
/*******************************************************************\

Function: cbmc_solverst::get_yices

  Inputs:

 Outputs:

 Purpose:

\*******************************************************************/
	  
prop_convt* cbmc_solverst::get_yices()
{
  return get_smt1(smt1_dect::YICES);
}
	  
/*******************************************************************\

Function: cbmc_solverst::no_beautification

  Inputs:

 Outputs:

 Purpose:

\*******************************************************************/

void cbmc_solverst::no_beautification() {
  if(options.get_bool_option("beautify-pbs") ||
     options.get_bool_option("beautify-greedy"))
    throw "sorry, this solver does not support beautification";
}

void cbmc_solverst::no_incremental_check() {
  if(options.get_bool_option("all-claims") ||
     options.get_bool_option("cover-assertions") ||
     options.get_option("incremental-check")!="")
    throw "sorry, this solver does not support incremental solving";
}
