/*******************************************************************\

Module: Solvers for VCs Generated by Symbolic Execution of ANSI-C

Author: Daniel Kroening, kroening@kroening.com

\*******************************************************************/

#include <memory>
#include <iostream>

#include <solvers/sat/satcheck.h>
#include <solvers/sat/satcheck_minisat2.h>

#ifdef HAVE_BV_REFINEMENT
#include <bv_refinement/bv_refinement_loop.h>
#endif

#include <solvers/smt1/smt1_dec.h>
#include <solvers/smt2/smt2_dec.h>
#include <solvers/cvc/cvc_dec.h>

#include <solvers/prop/aig_prop.h>
#include <solvers/sat/dimacs_cnf.h>


#include "cbmc_solvers.h"

#include "bv_cbmc.h"
#include "counterexample_beautification.h"
#include "version.h"



/*******************************************************************\

Function: cbmc_solverst::get_default

  Inputs:

 Outputs:

 Purpose: Get the default decision procedure

\*******************************************************************/

prop_convt* cbmc_solverst::get_default()
{
  bv_cbmct* bv_cbmc;
  if(options.get_bool_option("beautify") || 
     options.get_bool_option("all-claims") ||
     options.get_bool_option("cover-assertions") ||
     options.get_option("incremental-check")!="")
  {
    // simplifier won't work with beautification
    prop = new satcheck_minisat_no_simplifiert();
    prop->set_message_handler(get_message_handler());
    prop->set_verbosity(get_verbosity());
    
    bv_cbmc = new bv_cbmct(ns, *prop);
    
    if(options.get_option("arrays-uf")=="never")
      bv_cbmc->unbounded_array=bv_cbmct::U_NONE;
    else if(options.get_option("arrays-uf")=="always")
      bv_cbmc->unbounded_array=bv_cbmct::U_ALL;
  }
  else
  {
    #if 1
    prop = new satcheckt();
    #else
    aig = new aigt();
    prop = new aig_propt(*aig);
    #endif

    prop->set_message_handler(get_message_handler());
    prop->set_verbosity(get_verbosity());
    
    bv_cbmc = new bv_cbmct(ns, *prop);
    
    if(options.get_option("arrays-uf")=="never")
      bv_cbmc->unbounded_array=bv_cbmct::U_NONE;
    else if(options.get_option("arrays-uf")=="always")
      bv_cbmc->unbounded_array=bv_cbmct::U_ALL;
  }

  return bv_cbmc;
}

/*******************************************************************\

Function: cbmc_solverst::get_dimacs

  Inputs:

 Outputs:

 Purpose:

\*******************************************************************/
 
prop_convt* cbmc_solverst::get_dimacs()
{
  prop = new dimacs_cnft();
  prop->set_message_handler(get_message_handler());

  return new bv_cbmct(ns, *prop);
}


/*******************************************************************\

Function: cbmc_solverst::get_bv_refinement

  Inputs:

 Outputs:

 Purpose:

\*******************************************************************/
 
prop_convt* cbmc_solverst::get_bv_refinement()
{
  #ifdef HAVE_BV_REFINEMENT

  no_beautification();
  no_incremental_check();

  prop = new satcheckt();
  prop->set_message_handler(get_message_handler());
  prop->set_verbosity(get_verbosity());

  return new bv_refinement_loopt(ns, *prop);
  
  #else
  throw "bv refinement not linked in";
  #endif
}

/*******************************************************************\

Function: cbmc_solverst::get_smt1

  Inputs:

 Outputs:

 Purpose:

\*******************************************************************/
 
prop_convt* cbmc_solverst::get_smt1(smt1_dect::solvert solver)
{
  no_beautification();
  no_incremental_check();

  const std::string &filename=options.get_option("outfile");
  
  if(filename=="")
  {
    smt1_dect* smt1_dec = new smt1_dect(
      ns,
      "cbmc",
      "Generated by CBMC " CBMC_VERSION,
      "QF_AUFBV",
      solver);
    return smt1_dec;
  }
  else if(filename=="-") {
    smt1_convt* smt1_conv = new smt1_convt(
      ns,
      "cbmc",
      "Generated by CBMC " CBMC_VERSION,
      "QF_AUFBV",
      std::cout);
    smt1_conv->set_message_handler(get_message_handler());
    return smt1_conv;
  }
  else
  {
    std::ofstream out(filename.c_str());
    if(!out)
    {
      std::cerr << "failed to open " << filename << std::endl;
      return false;
    }
    smt1_convt* smt1_conv = new smt1_convt(
      ns,
      "cbmc",
      "Generated by CBMC " CBMC_VERSION,
      "QF_AUFBV",
      std::cout);
    smt1_conv->set_message_handler(get_message_handler());
    return smt1_conv;
  }
}
  
/*******************************************************************\

Function: cbmc_solverst::get_smt2

  Inputs:

 Outputs:

 Purpose:

\*******************************************************************/
   
prop_convt* cbmc_solverst::get_smt2(smt2_dect::solvert solver)
{
  no_beautification();
  no_incremental_check();

  const std::string &filename=options.get_option("outfile");
  
  if(filename=="")
  {
    smt2_dect* smt2_dec = new smt2_dect(
      ns,
      "cbmc",
      "Generated by CBMC " CBMC_VERSION,
      "QF_AUFBV",
      solver);

    if(options.get_bool_option("fpa"))
      smt2_dec->use_FPA_theory=true;

    return smt2_dec;
  }
  else if(filename=="-") {
    smt2_convt* smt2_conv = new smt2_convt(
      ns,
      "cbmc",
      "Generated by CBMC " CBMC_VERSION,
      "QF_AUFBV",
      std::cout);

    if(options.get_bool_option("fpa"))
      smt2_conv->use_FPA_theory=true;

    smt2_conv->set_message_handler(get_message_handler());
    return smt2_conv;
  }
  else
  {
    std::ofstream out(filename.c_str());
    if(!out)
    {
      std::cerr << "failed to open " << filename << std::endl;
      return false;
    }
    smt2_convt* smt2_conv = new smt2_convt(
      ns,
      "cbmc",
      "Generated by CBMC " CBMC_VERSION,
      "QF_AUFBV",
      out);

    if(options.get_bool_option("fpa"))
      smt2_conv->use_FPA_theory=true;

    smt2_conv->set_message_handler(get_message_handler());
    return smt2_conv;
  }
}

/*******************************************************************\

Function: cbmc_solverst::get_cvc

  Inputs:

 Outputs:

 Purpose:

\*******************************************************************/
     
prop_convt* cbmc_solverst::get_cvc()
{
  return get_smt1(smt1_dect::CVC3);
}
    
/*******************************************************************\

Function: cbmc_solverst::get_boolector

  Inputs:

 Outputs:

 Purpose:

\*******************************************************************/
      
prop_convt* cbmc_solverst::get_boolector()
{
  return get_smt1(smt1_dect::BOOLECTOR);
}

/*******************************************************************\

Function: cbmc_solverst::get_mathsat

  Inputs:

 Outputs:

 Purpose:

\*******************************************************************/
       
prop_convt* cbmc_solverst::get_mathsat()
{
  if(options.get_bool_option("smt2"))
    return get_smt2(smt2_dect::MATHSAT);
  else
    return get_smt1(smt1_dect::MATHSAT);
}
      
/*******************************************************************\

Function: cbmc_solverst::get_opensmt

  Inputs:

 Outputs:

 Purpose:

\*******************************************************************/
	
prop_convt* cbmc_solverst::get_opensmt()
{
  return get_smt1(smt1_dect::OPENSMT);
}

/*******************************************************************\

Function: cbmc_solverst::get_z3

  Inputs:

 Outputs:

 Purpose:

\*******************************************************************/
	 
prop_convt* cbmc_solverst::get_z3()
{
  return get_smt2(smt2_dect::Z3);
}
	 
/*******************************************************************\

Function: cbmc_solverst::get_yices

  Inputs:

 Outputs:

 Purpose:

\*******************************************************************/
	  
prop_convt* cbmc_solverst::get_yices()
{
  return get_smt1(smt1_dect::YICES);
}
	  
/*******************************************************************\

Function: cbmc_solverst::no_beautification

  Inputs:

 Outputs:

 Purpose:

\*******************************************************************/

void cbmc_solverst::no_beautification() {
  if(options.get_bool_option("beautify-pbs") ||
     options.get_bool_option("beautify-greedy"))
    throw "sorry, this solver does not support beautification";
}

void cbmc_solverst::no_incremental_check() {
  if(options.get_bool_option("all-claims") ||
     options.get_bool_option("cover-assertions") ||
     options.get_option("incremental-check")!="")
    throw "sorry, this solver does not support incremental solving";
}
